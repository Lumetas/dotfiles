#!/usr/bin/env python3

import os
import sys
import json
import subprocess
import shlex

def load_config_recursive(config, base_path=''):
    """
    Рекурсивно загружает конфигурацию, обрабатывая вложенные @include
    """
    result = {}
    
    for key, value in config.items():
        # Если значение начинается с @include:, обрабатываем как инклюд
        if isinstance(value, str) and value.startswith('@include:'):
            include_file = value[len('@include:'):]
            
            # Если путь относительный, добавляем базовый путь
            if base_path and not include_file.startswith('/'):
                include_file = os.path.join(base_path, include_file)
            
            if not os.path.exists(include_file):
                print(f"Warning: Include file not found: {include_file}")
                continue
            
            try:
                with open(include_file, 'r') as f:
                    included_config = json.load(f)
            except (json.JSONDecodeError, IOError) as e:
                print(f"Warning: Invalid JSON or cannot read include file: {include_file} - {e}")
                continue
            
            # Рекурсивно обрабатываем включенный конфиг
            result[key] = load_config_recursive(included_config, os.path.dirname(include_file))
        elif isinstance(value, dict):
            # Рекурсивно обрабатываем вложенные словари
            result[key] = load_config_recursive(value, base_path)
        else:
            # Обычное значение
            result[key] = value
    
    return result

def run_shell_command(cmd):
    """Выполняет shell команду и возвращает результат"""
    try:
        result = subprocess.run(
            cmd, 
            shell=True, 
            capture_output=True, 
            text=True
        )
        return result.returncode, result.stdout.strip(), result.stderr.strip()
    except Exception as e:
        return -1, '', str(e)

def enabler(elements):
    """Включает элементы с помощью stow"""
    enabled = {}
    
    for element, element_data in elements.items():
        if isinstance(element_data, dict) and element_data.get('active', False):
            enabled[element] = element_data
        else:
            # Отключаем неактивные элементы
            returncode, stdout, stderr = run_shell_command(f"stow -D {shlex.quote(element)}")
            if returncode != 0:
                print(f"Warning: Failed to disable {element}: {stderr}")
    
    for element, element_data in enabled.items():
        # Включаем активные элементы
        inDir = ""
        if element_data.get('path'):
            inDir = "-t " + element_data.get('path')
        returncode, stdout, stderr = run_shell_command(f"stow {inDir} {shlex.quote(element)}")
        if returncode != 0:
            print(f"Warning: Failed to enable {element}: {stderr}")
        else:
            # Запускаем команду build если есть
            if isinstance(element_data, dict) and 'build' in element_data:
                build_cmd = element_data['build']
                print(f"Running build command for {element}: {build_cmd}")
                returncode, stdout, stderr = run_shell_command(build_cmd)
                if returncode != 0:
                    print(f"Warning: Build command failed for {element}: {stderr}")

def disabler(elements):
    """Отключает элементы с помощью stow"""
    for element, element_data in elements.items():
        returncode, stdout, stderr = run_shell_command(f"stow -D {shlex.quote(element)}")
        if returncode != 0:
            print(f"Warning: Failed to disable {element}: {stderr}")

def expand_path(path):
    """Расширяет пути с ~/ до домашней директории"""
    if path.startswith('~/'):
        return os.path.join(os.path.expanduser('~'), path[2:])
    return path

def clone_extra_pkgs(extra_pkgs):
    """Клонирует дополнительные пакеты из Git"""
    for path, url in extra_pkgs.items():
        expanded_path = expand_path(path)
        
        # Создаем директорию, если не существует
        dir_path = os.path.dirname(expanded_path)
        if not os.path.exists(dir_path):
            try:
                os.makedirs(dir_path, 0o755, exist_ok=True)
            except OSError as e:
                print(f"Warning: Failed to create directory {dir_path}: {e}")
                continue
        
        if not os.path.exists(expanded_path):
            print(f"Cloning: {url} to {expanded_path}")
            returncode, stdout, stderr = run_shell_command(
                f"git clone {shlex.quote(url)} {shlex.quote(expanded_path)}"
            )
            if returncode != 0:
                print(f"Warning: Failed to clone {url}: {stderr}")

def uninstall_extra_pkgs(config):
    """Удаляет дополнительные пакеты"""
    if 'extraPkgs' in config:
        extra_pkgs = config['extraPkgs']
        for path, url in extra_pkgs.items():
            expanded_path = expand_path(path)
            if os.path.exists(expanded_path):
                print(f"Removing: {expanded_path}")
                try:
                    if os.path.isdir(expanded_path):
                        import shutil
                        shutil.rmtree(expanded_path)
                    else:
                        os.remove(expanded_path)
                except OSError as e:
                    print(f"Warning: Failed to remove {expanded_path}: {e}")

def get_package_config_for_distro(pkg_config, distro):
    """Получает конфигурацию пакета для текущего дистрибутива"""
    if distro in pkg_config:
        return pkg_config[distro]
    
    # Если нет конфигурации для текущего дистрибутива, проверяем наличие default
    if 'default' in pkg_config:
        return pkg_config['default']
    
    # Если нет ни дистрибутива, ни default, возвращаем None
    return None

def check_package_installed(pkg_name, distro_config):
    """Проверяет, установлен ли пакет"""
    if 'checkCmd' not in distro_config:
        return False
    
    # Проблема: checkCmd использует jq как жестко закодированный пакет
    # Нужно заменить %pkg% на реальное имя пакета
    check_cmd = distro_config['checkCmd'].replace('jq', pkg_name).replace('%pkg%', pkg_name)
    returncode, stdout, stderr = run_shell_command(check_cmd)
    
    if returncode == 0 and stdout.strip() == "1":
        return True
    return False

def install_package(pkg_name, distro_config):
    """Устанавливает пакет"""
    if 'installCmd' not in distro_config:
        print(f"Error: No install command defined for {distro_config}")
        return False
    
    install_cmd = distro_config['installCmd'].replace('%pkg%', pkg_name)
    print(f"Installing package: {pkg_name}")
    returncode, stdout, stderr = run_shell_command(install_cmd)
    
    if returncode != 0:
        print(f"Error: Failed to install {pkg_name}: {stderr}")
        return False
    
    return True

def remove_package(pkg_name, distro_config):
    """Удаляет пакет"""
    if 'removeCmd' not in distro_config:
        print(f"Error: No remove command defined for {distro_config}")
        return False
    
    remove_cmd = distro_config['removeCmd'].replace('%pkg%', pkg_name)
    print(f"Removing package: {pkg_name}")
    returncode, stdout, stderr = run_shell_command(remove_cmd)
    
    if returncode != 0:
        print(f"Error: Failed to remove {pkg_name}: {stderr}")
        return False
    
    return True

def manage_packages(config):
    """Управляет пакетами на основе декларативной конфигурации"""
    if 'dependencies' not in config or 'distros' not in config:
        print("Warning: No dependencies or distros defined in config")
        return
    
    # Получаем текущий дистрибутив
    current_distro = config.get('currentDistro')
    if not current_distro:
        print("Error: currentDistro not defined in config")
        return
    
    # Получаем конфиг текущего дистрибутива
    distro_config = config['distros'].get(current_distro)
    if not distro_config:
        print(f"Error: No configuration found for distro: {current_distro}")
        return
    
    print(f"Managing packages for distro: {current_distro}")
    
    # Обрабатываем все зависимости
    for pkg_key, pkg_config in config['dependencies'].items():
        if not isinstance(pkg_config, dict):
            continue
        
        # Получаем конфигурацию пакета для текущего дистрибутива
        pkg_distro_config = get_package_config_for_distro(pkg_config, current_distro)
        if not pkg_distro_config:
            print(f"Warning: No configuration for {pkg_key} on {current_distro}")
            continue
        
        # Получаем имя пакета и статус
        pkg_name = pkg_distro_config.get('name')
        if not pkg_name:
            print(f"Warning: No package name defined for {pkg_key} on {current_distro}")
            continue
        
        should_be_installed = pkg_distro_config.get('installed', False)
        
        # Проверяем текущее состояние
        is_installed = check_package_installed(pkg_name, distro_config)
        
        print(f"Package: {pkg_key} ({pkg_name}) - Should be installed: {should_be_installed}, Is installed: {is_installed}")
        
        # Приводим систему к желаемому состоянию
        if should_be_installed and not is_installed:
            # Пакет должен быть установлен, но не установлен
            if not install_package(pkg_name, distro_config):
                print(f"Failed to install {pkg_key}")
            else:
                print(f"Successfully installed {pkg_key}")
        
        elif not should_be_installed and is_installed:
            # Пакет не должен быть установлен, но установлен
            if not remove_package(pkg_name, distro_config):
                print(f"Failed to remove {pkg_key}")
            else:
                print(f"Successfully removed {pkg_key}")
        
        else:
            # Состояние соответствует желаемому
            print(f"Package {pkg_key} is already in correct state")

def show_help():
    """Показывает справку по использованию"""
    help_text = """Usage:
  python3 script.py          - Install/configure packages and dependencies
  python3 script.py packages - Manage only package dependencies (install/remove)
  python3 script.py uninstall - Disable packages and stow configs
  python3 script.py remove    - Disable packages, remove extra files and packages
  python3 script.py help      - Show this help

This script expects config.json in the current working directory.
"""
    print(help_text)

def main():
    # Определяем путь к config.json в текущей рабочей директории
    config_path = 'config.json'
    
    # Загружаем основной конфиг
    try:
        with open(config_path, 'r') as f:
            main_config = json.load(f)
    except (json.JSONDecodeError, IOError) as e:
        print(f"Error: Invalid JSON or cannot read {config_path}: {e}")
        print(f"Current directory: {os.getcwd()}")
        sys.exit(1)
    
    # Рекурсивно обрабатываем инклюды
    config = load_config_recursive(main_config, os.path.dirname(config_path))
    
    # Обработка аргументов командной строки
    if len(sys.argv) >= 2:
        if sys.argv[1] == 'packages':
            print("Managing packages only...")
            manage_packages(config)
            sys.exit(0)
        
        if sys.argv[1] == 'uninstall':
            print("Uninstalling packages...")
            if 'WM' in config:
                disabler(config['WM'])
            if 'PKGS' in config:
                disabler(config['PKGS'])
            sys.exit(0)
        
        if sys.argv[1] == 'remove':
            print("Removing packages, extra files and uninstalling...")
            # Сначала отключаем все stow конфигурации
            if 'WM' in config:
                disabler(config['WM'])
            if 'PKGS' in config:
                disabler(config['PKGS'])
            
            # Удаляем лишние файлы
            uninstall_extra_pkgs(config)
            
            # Удаляем пакеты, которые должны быть удалены
            manage_packages(config)
            sys.exit(0)
        
        if sys.argv[1] in ['help', '--help', '-h']:
            show_help()
            sys.exit(0)
    
    print("Starting full system configuration...")
    
    # 1. Управляем пакетами из dependencies
    manage_packages(config)
    
    # 2. Клонируем дополнительные пакеты
    if 'extraPkgs' in config:
        clone_extra_pkgs(config['extraPkgs'])
    
    # 3. Включаем конфигурации через stow
    if 'WM' in config:
        enabler(config['WM'])
    
    if 'PKGS' in config:
        enabler(config['PKGS'])
    
    print("Configuration completed!")

if __name__ == '__main__':
    main()
